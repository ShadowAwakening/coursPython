#!/usr/bin/python3# -*-coding:UTF-8 -*##################################################### TRANSFORMATION CHAINE EN LISTE/ LISTE EN CHAINE####################################################maList = ['salut', 'les', 'gens']print(" ".join(maList))maChaine = "salut les gens"print(maChaine.split())##################################################### fONCTION RESTREINDRE DECIMALE: FLOTTANT -> ",".join([...])####################################################def afficher_flottant(flottant):    if type(flottant) is not float:        raise TypeError("Le parametre attendu doit etre un flottant")    num = str(flottant)    partie_entiere, partie_decimale = num.split(".")    return ",".join([partie_entiere, partie_decimale[:3]])print(afficher_flottant(4.3333333333))##################################################### FONCTION INCONNU####################################################def fonction_inconnu(*parametres):    print("J'ai recus {}".format(parametres))fonction_inconnu(4)fonction_inconnu("deux parametre", ["hey !"])fonction_inconnu(4, 8, 9, 12)fonction_inconnu(4, 'Hello', ("revert", "balance"))##################################################### FONCTION INCONNU: CREATION COPIE DE LA FONCTION PRINT####################################################def afficher(*parametres, sep=' ', fin='\n'):    """    Fonction charge de reproduire le compotement de print()    Elle doit finir par un appel a print pour afficher le resultat.    Les parametres devrons dejas avoir ete formates.    On dois passer a print une unique chaine, en lui specifiant de ne    rien mettre a la fin: print(chaine, end='')    """    # Les paramètres sont sous la forme d'un tuple    # Or on a besoin de les convertir    # Mais on ne peut pas modifier un tuple    # On a plusieurs possibilités, ici je choisis de convertir le tuple en liste    parametres = list(parametres)    # On va commencer par convertir toutes les valeurs en chaîne    # Sinon on va avoir quelques problèmes lors du join    for i, parametre in enumerate(parametres):        parametres[i] = str(parametre)    # La liste des paramètres ne contient plus que des chaînes de caractères    # À présent on va constituer la chaîne finale    chaine = sep.join(parametres)    # On ajoute le paramètre fin à la fin de la chaîne    chaine += fin    # On affiche l'ensemble    print(chaine, end='')afficher(32)############################################################ LA COMPREHENSIONS DE LISTE: Modifier une liste simplement# SYNTAXE: nouvelle_squence = [element for element in ancienne_squence if condition]############################################################ Parcour simpleliste_origine = [0, 1, 2, 3, 4, 5]print([nb * nb for nb in liste_origine])# Filtrage avec branchement conditionnelliste_origine1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]print([nb for nb in liste_origine1 if nb % 2 == 0])# Ici grace a la condition on affiche seulement les nombres pairs# Exemple complet en melangeant les 2 techniques:qtt_a_retirer = 7  # On retire chaque semaine 7 fruits de chaque sortefruits_stockes = [15, 3, 18, 21]  # Par exemple 15 pommes, 3 melons...print([nb_fruits - qtt_a_retirer for nb_fruits in fruits_stockes if       nb_fruits > qtt_a_retirer])# Applicationinventaire = [ ("pommes", 22), ("melons", 4), ("poires", 18), ("fraises", 76), ("prunes", 51),]inventaire_inverse = [(qte, nom_fruit) for nom_fruit, qte in inventaire]inventaire = [(nom_fruit, qte) for qte, nom_fruit in sorted(    inventaire_inverse, reverse=True)]print(inventaire)# OU# On change le sens de l'inventaire, la quantité avant le nominventaire_inverse = [(qtt, nom_fruit) for nom_fruit,qtt in inventaire]# On trie l'inventaire inversé dans l'ordre décroissantinventaire_inverse.sort(reverse=True)# Et on reconstitue l'inventaireinventaire = [(nom_fruit, qtt) for qtt,nom_fruit in inventaire_inverse]